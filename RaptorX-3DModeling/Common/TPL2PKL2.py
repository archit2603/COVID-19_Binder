import os
import sys
import numpy as np
import cPickle

from LoadTPLTGT import load_tpl as LoadTPL
import PDBUtils
from DL4DistancePrediction4 import ContactUtils
from SSUtils import SS8Letter2Code, SS8Letter2SS3Code, SS8Letter2SS3Letter

def Usage():
	print ' python TPL2PKL2.py tplfile pdbfile [ResDir]'
	print '	This script generates a .tpl.pkl file from an old .tpl file and .pdb file'
	print '	the .tpl file is generated by an old TPL_package '
	print '	the resultant file is named after proteinName.tpl.pkl and saved to ResDir if provided or current work directory'

if __name__ == "__main__":
	if len(sys.argv) < 3:
		Usage()
		exit(1)

	tplfile = sys.argv[1]
	pdbfile = sys.argv[2]

	ResDir=os.getcwd()
	if len(sys.argv)>=4:
		ResDir = sys.argv[3]
		if not os.path.isdir(ResDir):
			os.mkdir(ResDir)

	protein = LoadTPL(tplfile)

        result, pdbseq, numMisMatches, numMatches = PDBUtils.ExtractCoordinatesNDSSPBySeq(protein['sequence'], pdbfile)

        if numMisMatches > 5:
                print 'ERROR: too many mismatches between TPL sequence and ATOM record in ', pdbfile
                exit(1)

        if numMatches < min(30, 0.5*len(protein['sequence']) ):
                print 'ERROR: more than half of TPL sequence not covered by ATOM record in ', pdbfile
                exit(1)

        coordInfo, dssp = result
        coordinates, numInvalidAtoms = coordInfo

        if numInvalidAtoms.has_key('CA') and numInvalidAtoms['CA']>10:
                print 'ERROR: too many (', numInvalidAtoms['CA'], ') Ca atoms do not have valid 3D coordinates in ', pdbfile
                exit(1)
        if numInvalidAtoms.has_key('CB') and numInvalidAtoms['CB']>10:
                print 'ERROR: too many (', numInvalidAtoms['CB'], ') Cb atoms do not have valid 3D coordinates in ', pdbfile
                exit(1)

	protein.update(dssp)

        length = protein['length']
        protein['SS3Coding'] = np.zeros( (length, 3), np.float32)
        protein['SS8Coding'] = np.zeros( (length, 8), np.float32)

        for i, s in zip( range(length), protein['SS8'] ):
                protein['SS3Coding'][i, SS8Letter2SS3Code[s] ] = 1
                protein['SS8Coding'][i, SS8Letter2Code[s] ] = 1

        protein['pdbseq'] = pdbseq
        protein['numMisMatches'] = numMisMatches
        protein['numMatches'] = numMatches

        protein['missing'] = np.array([ c is None or (c['CA'] is None and c['CB'] is None) for c in coordinates ]).astype(np.int16)

        def GetAtomCoordinates(coordinates, atomName):
                return [ tuple(c[atomName]) if (c is not None and c[atomName] is not None) else None for c in coordinates ]

        protein['Ca'] = GetAtomCoordinates(coordinates, 'CA')
	protein['Cb'] = GetAtomCoordinates(coordinates, 'CB')
        protein['N'] = GetAtomCoordinates(coordinates, 'N')
        protein['O'] = GetAtomCoordinates(coordinates, 'O')
        protein['Cg'] = GetAtomCoordinates(coordinates, 'CG')

        distMatrix = PDBUtils.CalcDistMatrix(coordinates)
        protein['atomDistMatrix'] = PDBUtils.PostProcessDistMatrix(protein['sequence'], distMatrix)

        protein['CNa'] = ContactUtils.CalcContactNumber( ContactUtils.FromDistMatrix(distMatrix['CaCa']) )
        protein['CNb'] = ContactUtils.CalcContactNumber( ContactUtils.FromDistMatrix(distMatrix['CbCb']) )

        oriMatrix = PDBUtils.CalcTwoROriMatrix(coordinates)
        protein['atomOrientationMatrix'] = oriMatrix

        oriMatrix = PDBUtils.CalcCaOriMatrix(coordinates)
        protein['atomOrientationMatrix'].update(oriMatrix)

        ## assign theta and tau
        seqLen = length
        Theta = np.array([ -720 ] * seqLen, dtype=np.float16)
        for i in range(seqLen-2):
                Theta[i+1] = oriMatrix['Ca1Ca2Ca3'][i, i+2]

        Tau = np.array([ -720 ] *seqLen, dtype=np.float16)
        Tau[i+2]=oriMatrix['Ca1Ca2Ca3Ca4'][i, i+2]

        protein['Theta'] = Theta
        protein['Tau'] = Tau

        savefile = os.path.join(ResDir, protein['name'] + '.tpl.pkl')
        with open(savefile, 'w') as fh:
                cPickle.dump(protein, fh, protocol=cPickle.HIGHEST_PROTOCOL)
