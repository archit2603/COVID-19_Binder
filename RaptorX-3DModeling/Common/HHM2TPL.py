import os
import sys
import numpy as np
import cPickle
import random

def Usage():
	print ' HHM2TPL.py hhmfile pdbfile [ResDir]'
	print '	This script generatesa template file from a .hhm file and a PDB file'
	print '	the .hhm file is generated by hhmake in HHsuites '
	print '	the resultant template file is named after proteinName.tpl.pkl and saved to ResDir if provided or current work directory'
	print '	ResDir: optinal, if not provided, then save results to current work directory'


## this script generates a TPL file from .hhm and .pdb files
## we try to be compatible with the old TPL content
## the result is saved into a .tpl.pkl file

from LoadHHM import load_hhm as LoadHHM
from SequenceUtils import DetectMultiHIS
import PDBUtils
from SSUtils import SS8Letter2Code, SS8Letter2SS3Code, SS8Letter2SS3Letter
from DL4DistancePrediction4 import ContactUtils
from CIF2PDB import CIF2PDB

if __name__ == "__main__":
	if len(sys.argv) < 3:
		Usage()
		exit(1)

	hhmfile = sys.argv[1]
	structfile = sys.argv[2]
	pdbfileIsTemporary = False

	ResDir=os.getcwd()
	if len(sys.argv)>=4:
		ResDir = sys.argv[3]
		if not os.path.isdir(ResDir):
			print 'ERROR: the folder for result saving does not exist: ', ResDir
			exit(1)

	if structfile.endswith('.cif'):
		## convert this file to a temporary PDB file; we do this conversion because the old dssp does not work for .cif file 
		## and the new dssp does not work with the .cif file generated by SelectProteinChains.py
		pdbfile = os.path.basename(structfile).split('.')[0] + str(os.getpid()) + str(random.randint(0, 1000)) + '.pdb'
		pdbfile = os.path.join(ResDir, pdbfile)
		CIF2PDB(structfile, pdbfile)
		pdbfileIsTemporary = True

	elif structfile.endswith('.pdb'):
		pdbfile = structfile
	else:
		print 'ERROR: the input structure file shall end with .cif or .pdb'
		exit(1)

	hhm = LoadHHM(hhmfile)

	protein = dict()
	for k in ['name', 'sequence', 'length', 'NEFF', 'PSFM', 'PSSM', 'DateCreated', 'HMMHeader']:
		protein[k] = hhm[k]

	protein['HISflag'] = DetectMultiHIS(protein['sequence'])	

	result, pdbseq, numMisMatches, numMatches = PDBUtils.ExtractCoordinatesNDSSPBySeq(protein['sequence'], pdbfile)

	if numMisMatches > 5:
                print 'ERROR: too many mismatches between HHM sequence and ATOM record in ', pdbfile
                exit(1)

        if numMatches < min(30, 0.5*len(protein['sequence']) ):
                print 'ERROR: more than half of HHM sequence not covered by ATOM record in ', pdbfile
                exit(1)

	coordInfo, dssp = result

	coordinates, numInvalidAtoms = coordInfo

	if numInvalidAtoms.has_key('CA') and numInvalidAtoms['CA']>10:
		print 'ERROR: too many (', numInvalidAtoms['CA'], ') Ca atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	if numInvalidAtoms.has_key('CB') and numInvalidAtoms['CB']>10:
		print 'ERROR: too many (', numInvalidAtoms['CB'], ') Cb atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	
	protein.update(dssp)

	length = protein['length']
	protein['SS3Coding'] = np.zeros( (length, 3), np.float32)
        protein['SS8Coding'] = np.zeros( (length, 8), np.float32)

	for i, s in zip( range(length), protein['SS8'] ):
		protein['SS3Coding'][i, SS8Letter2SS3Code[s] ] = 1
                protein['SS8Coding'][i, SS8Letter2Code[s] ] = 1

	protein['pdbseq'] = pdbseq
	protein['numMisMatches'] = numMisMatches
	protein['numMatches'] = numMatches

        protein['missing'] = np.array([ c is None or (c['CA'] is None and c['CB'] is None) for c in coordinates ]).astype(np.int16)

	def GetAtomCoordinates(coordinates, atomName):
		return [ tuple(c[atomName]) if (c is not None and c[atomName] is not None) else None for c in coordinates ]

	protein['Ca'] = GetAtomCoordinates(coordinates, 'CA')
	protein['Cb'] = GetAtomCoordinates(coordinates, 'CB')
	"""
	protein['N'] = GetAtomCoordinates(coordinates, 'N')
	protein['O'] = GetAtomCoordinates(coordinates, 'O')
	protein['Cg'] = GetAtomCoordinates(coordinates, 'CG')
	"""

	distMatrix = PDBUtils.CalcDistMatrix(coordinates)
	protein['atomDistMatrix'] = PDBUtils.PostProcessDistMatrix(protein['sequence'], distMatrix)

	protein['CNa'] = ContactUtils.CalcContactNumber( ContactUtils.FromDistMatrix(distMatrix['CaCa']) )
	protein['CNb'] = ContactUtils.CalcContactNumber( ContactUtils.FromDistMatrix(distMatrix['CbCb']) )

	oriMatrix = PDBUtils.CalcTwoROriMatrix(coordinates)
	protein['atomOrientationMatrix'] = oriMatrix

	oriMatrix = PDBUtils.CalcCaOriMatrix(coordinates)
	protein['atomOrientationMatrix'].update(oriMatrix)

	## assign theta and tau
	seqLen = length
	Theta = np.array([ -720 ] * seqLen, dtype=np.float16)
	for i in range(seqLen-2):
        	Theta[i+1] = oriMatrix['Ca1Ca2Ca3'][i, i+2]

	Tau = np.array([ -720 ] *seqLen, dtype=np.float16)
	for i in range(seqLen-2):
        	Tau[i+2]=oriMatrix['Ca1Ca2Ca3Ca4'][i, i+2]

	protein['Theta'] = Theta
	protein['Tau'] = Tau

	savefile = os.path.join(ResDir, protein['name'] + '.tpl.pkl')
	with open(savefile, 'w') as fh:
		cPickle.dump(protein, fh, protocol=cPickle.HIGHEST_PROTOCOL)

	if pdbfileIsTemporary:
		os.remove(pdbfile)
